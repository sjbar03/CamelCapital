open Column

type table = string list list

let empty_table : table = []

let print_table (table : table) =
  let () = print_string "##############   TABLE   ##############" in
  let () = print_newline () in
  let () = table |> Csv.transpose |> Csv.print_readable |> print_newline in
  print_endline "##############     END      ##############"

type dataframe = {
  row_major : table;
  col_major : table;
}

let int_data x default =
  match int_of_string_opt x with
  | None -> default
  | Some v -> v

let string_data x default : string =
  match x with
  | "" -> default
  | x -> x

let float_data x default =
  match float_of_string_opt x with
  | None -> default
  | Some v -> v

let dataframe_from_csv filepath : dataframe =
  let matrix : string list list = Csv.(load filepath) in
  let row_major = Csv.square matrix in
  let col_major =
    let ts = Csv.transpose matrix in
    Csv.square ts
  in
  { row_major; col_major }

let empty_dataframe : dataframe = { row_major = []; col_major = [] }

let cons_col_to_row_major (col : col) (table : table) : table =
  let col : string list = to_lst col in
  if List.length table = 0 then
    let f x = [ x ] in
    List.map f col
  else
    let f x y = x :: y in
    List.map2 f col table

let add_col_to_dataframe (col : col) (dataframe : dataframe) : dataframe =
  let dataframe =
    { dataframe with col_major = to_lst col :: dataframe.col_major }
  in
  let row_major = cons_col_to_row_major col dataframe.row_major in
  { dataframe with row_major }

let rec add_cols_to_dataframe (table : table) dataframe =
  match table with
  | [] -> dataframe
  | col :: rest ->
      add_cols_to_dataframe rest
        (add_col_to_dataframe (col_from_lst col) dataframe)

let find_col_from_dataframe label dataframe : table =
  let table = dataframe.col_major in
  if List.is_empty table then table
  else
    let f label = function
      | [] -> false
      | h :: _ -> if h = label then true else false
    in
    List.filter (f label) table

let remove_col_from_dataframe label dataframe : dataframe =
  let table = dataframe.col_major in
  if List.is_empty table then dataframe
  else
    let f label = function
      | [] -> true
      | h :: _ -> if h <> label then true else false
    in
    let dataframe =
      { dataframe with col_major = List.filter (f label) table }
    in
    add_cols_to_dataframe dataframe.col_major empty_dataframe

let rec truncate_dataframe_aux i rows acc lst =
  if i > rows then acc
  else
    match lst with
    | [] -> acc
    | h :: t -> truncate_dataframe_aux (i + 1) rows (h :: acc) t

let truncate_dataframe dataframe rows : dataframe =
  let table = dataframe.col_major in
  if List.is_empty table then dataframe
  else
    let f acc elt_lst =
      List.rev (truncate_dataframe_aux 0 rows [] elt_lst) :: acc
    in
    let cols = List.fold_left f [] table in
    add_cols_to_dataframe cols empty_dataframe

let print_dataframe dataframe rows all =
  let () = print_string "##############   DATAFRAME  ##############" in
  let () = print_newline () in
  let () =
    if all = true then
      dataframe.row_major |> Csv.print_readable |> print_newline
    else
      let dataframe = truncate_dataframe dataframe rows in
      dataframe.row_major |> Csv.print_readable |> print_newline
  in
  print_endline "##############     END      ##############"

let map_dataframe_aux f acc elt_lst : table =
  let elt_lst =
    match elt_lst with
    | [] -> ("", [])
    | h :: t -> (h, t)
  in
  let label = fst elt_lst in
  (label :: List.map f (snd elt_lst)) :: acc

let map_dataframe f label dataframe =
  let table = dataframe.col_major in
  if List.is_empty table then dataframe
  else
    let table = find_col_from_dataframe label dataframe in
    let dataframe = remove_col_from_dataframe label dataframe in
    add_cols_to_dataframe
      (List.fold_left (map_dataframe_aux f) [] table)
      dataframe

let reduce_dataframe_aux (f : string -> string -> string) (acc : string) elt_lst
    =
  let elt_lst =
    match elt_lst with
    | [] -> ("", [])
    | h :: t -> (h, t)
  in
  let label = fst elt_lst in
  [ label; List.fold_left f acc (snd elt_lst) ]

let reduce_dataframe (f : string -> string -> string) (acc : string) label
    dataframe =
  let table = dataframe.col_major in
  if List.is_empty table then table
  else
    let table = find_col_from_dataframe label dataframe in
    let f' = reduce_dataframe_aux f acc in
    List.map f' table

let table_from_matrix (matrix : string list list) : table =
  (add_cols_to_dataframe matrix empty_dataframe).col_major

let rec label_position_aux label idx = function
  | [] -> -1
  | hd :: tl ->
      if hd = label then idx else label_position_aux label (idx + 1) tl

let label_position table label =
  match table with
  | [] -> -1
  | labels :: _ -> label_position_aux label 0 labels

let satisfy f pos lst =
  match List.nth_opt lst pos with
  | None -> false
  | Some element -> f element

let filtered_rows_f f pos lst = if satisfy f pos lst then true else false
let filtered_rows f pos table = List.filter (filtered_rows_f f pos) table

let filter_dataframe f label dataframe : dataframe =
  if List.is_empty dataframe.col_major then dataframe
  else
    let heading_rows =
      match dataframe.row_major with
      | [] -> ([], [])
      | h :: t -> (h, t)
    in
    let pos = label_position dataframe.col_major label in
    let rm =
      fst heading_rows
      :: (if pos > -1 then filtered_rows f pos (snd heading_rows) else [])
    in
    { row_major = rm; col_major = rm |> Csv.transpose }
